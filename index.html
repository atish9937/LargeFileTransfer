<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://largefiletransfer.org/">
    <meta name="theme-color" content="#667eea">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="DirectDrop">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <meta name="msapplication-TileImage" content="/icon-192.png">
    <meta name="msapplication-TileColor" content="#667eea">
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHJ4PSI4IiBmaWxsPSJ1cmwoI2dyYWRpZW50KSIvPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkaWVudCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IzlmN2FlYTtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgoKICA8IS0tIEZpbGUgdHJhbnNmZXIgaWNvbiAtLT4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2LCA2KSI+CiAgICA8IS0tIEZpcnN0IGRldmljZSAtLT4KICAgIDxyZWN0IHg9IjAiIHk9IjQiIHdpZHRoPSI4IiBoZWlnaHQ9IjEyIiByeD0iMS41IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC45Ii8+CiAgICA8cmVjdCB4PSIxIiB5PSI1IiB3aWR0aD0iNiIgaGVpZ2h0PSI4IiByeD0iMC41IiBmaWxsPSIjNjY3ZWVhIiBvcGFjaXR5PSIwLjMiLz4KCiAgICA8IS0tIFNlY29uZCBkZXZpY2UgLS0+CiAgICA8cmVjdCB4PSIxMiIgeT0iNCIgd2lkdGg9IjgiIGhlaWdodD0iMTIiIHJ4PSIxLjUiIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjkiLz4KICAgIDxyZWN0IHg9IjEzIiB5PSI1IiB3aWR0aD0iNiIgaGVpZ2h0PSI4IiByeD0iMC41IiBmaWxsPSIjNjY3ZWVhIiBvcGFjaXR5PSIwLjMiLz4KCiAgICA8IS0tIFRyYW5zZmVyIGFycm93IC0tPgogICAgPHBhdGggZD0iTTguNSAxMCBMMTEuNSAxMCBNMTAgOC41IEwxMS41IDEwIEwxMCAxMS41IiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CiAgPC9nPgo8L3N2Zz4K">
    <title>Large File Transfer | Send Files Up to 10GB Free | LargeFileTransfer.org</title>
    <meta name="description" content="LargeFileTransfer.org - Send large files up to 10GB for free. Fast, secure peer-to-peer file transfer with end-to-end encryption. No registration, no file size limits, no uploads to servers.">
    <meta name="keywords" content="large file transfer, send large files, file transfer online, large file sharing, free large file transfer, secure file transfer, peer to peer file transfer, encrypted file sharing, transfer large files free, large file transfer service, send big files, share large files online">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://largefiletransfer.org/">
    <meta property="og:title" content="Large File Transfer | Send Files Up to 10GB Free | LargeFileTransfer.org">
    <meta property="og:description" content="LargeFileTransfer.org - The fastest way to send large files up to 10GB for free. Secure peer-to-peer file transfer with end-to-end encryption. No registration required.">
    <meta property="og:image" content="https://largefiletransfer.org/secure-large-file-transfer-peer-to-peer.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://largefiletransfer.org/">
    <meta property="twitter:title" content="Large File Transfer | Send Files Up to 10GB Free">
    <meta property="twitter:description" content="LargeFileTransfer.org - Send large files up to 10GB for free with end-to-end encryption. No registration required.">
    <meta property="twitter:image" content="https://largefiletransfer.org/secure-large-file-transfer-peer-to-peer.jpg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="/style.css">

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "LargeFileTransfer.org",
        "description": "Send large files up to 10GB for free with LargeFileTransfer.org. The fastest, most secure peer-to-peer file transfer service with end-to-end encryption. No registration required.",
        "url": "https://largefiletransfer.org",
        "applicationCategory": "BusinessApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Send large files up to 10GB",
            "End-to-end encryption",
            "No registration required",
            "Peer-to-peer file transfer",
            "Secure file sharing",
            "Direct device-to-device transfer"
        ],
        "screenshot": "https://largefiletransfer.org/secure-large-file-transfer-peer-to-peer.jpg",
        "softwareVersion": "1.0",
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.8",
            "ratingCount": "1247"
        }
    }
    </script>
</head>
<body>
    <div id="navbar-container"></div>

    <main class="main-content-wrapper" role="main">

    <section class="container" aria-label="File transfer interface">
        <!-- Initial Screen -->
        <div id="select-screen" role="region" aria-label="File selection">
            <h1>Large Files Transfer Direct P2P Transfer - Up to 10GB Free</h1>
            <p class="subtitle">
                Need to send files too large for email? Transfer any file up to 10GB instantly with our secure file sharing service.
                No registration required, no uploads to servers - just direct, encrypted file transfer between your devices.
                Perfect for sending videos, photos, documents, and any file type that's too big for traditional email.
            </p>
            <div class="drop-area" id="drop-area" role="button" tabindex="0" aria-label="Drop zone for file upload">
                <p style="font-size: 0.9em; margin-bottom: 10px; color: #666;">Send files up to 10GB • No registration required</p>
                <p>Drag & Drop your large file here</p>
                <p style="font-size: 0.9em; margin-top: 3px;">or</p>
                <button class="btn" id="select-file-btn" aria-label="Choose file to send">Choose File to Send</button>
            </div>
            <input type="file" id="file-input" class="file-input" aria-label="File input" accept="*/*" />
            <div class="footer">
                <div class="security-badge">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"></path></svg>
                    Secure File Transfer End-to-End Encrypted Private
                </div>
            </div>
        </div>

        <!-- Share Screen -->
        <div id="share-screen" class="share-screen" role="region" aria-label="File sharing interface">
            <h2>Your file is ready to send</h2>
            <p>Share this link or QR code with the recipient.</p>
            <p style="margin: 10px;"><strong>Keep this page open untill transfer completes</strong></p>
            <input type="text" id="share-link" class="share-link" readonly />
            <div class="share-actions">
                <button class="btn btn-small" id="copy-link-btn">Copy Link</button>
                <button class="btn btn-small" id="share-btn">Share...</button>
            </div>
            <canvas id="qr-code"></canvas>
            <p><strong>Status:</strong> <span id="share-status">Waiting for recipient...</span></p>
            <div class="progress-bar" id="share-progress-bar">
                <div class="progress-bar-inner" id="share-progress"></div>
            </div>
            <button class="btn" id="send-another-btn" style="display: none; margin-top: 20px;">Send Another File</button>
        </div>

        <!-- Receive Screen -->
        <div id="receive-screen" class="receive-screen" role="region" aria-label="File receiving interface">
            <h2>Incoming File</h2>
            <p>You are about to receive a file.</p>
            <div class="file-info">
                <p><strong>Filename:</strong> <span id="file-name"></span></p>
                <p><strong>Size:</strong> <span id="file-size"></span></p>
            </div>
            <button class="btn" id="download-btn">Accept & Download</button>
            <button class="btn" id="cancel-btn" style="background-color: #dc3545; margin-left: 10px; display: none;">Cancel</button>
            <p id="receive-status" style="margin-top: 20px;"></p>
            <div class="progress-bar" id="receive-progress-bar">
                <div class="progress-bar-inner" id="receive-progress"></div>
            </div>
            <button class="btn" id="try-send-btn" style="display: none; margin-top: 20px;">Try Sending File</button>
        </div>

        <!-- Why Choose LargeFileTransfer Section -->
        <div class="why-choose-section">
            <h2 style="text-align: center;">The Fastest Way to Send Large Files Online</h2>
            <p>Tired of file size limits and slow uploads? LargeFileTransfer.org is the free solution for sending large files instantly.
            Our peer-to-peer technology creates a direct connection between your devices, making file transfers up to 3x faster than traditional cloud services.
            No more waiting for uploads or dealing with "file too large" errors.
            </p>
            <img src="/secure-large-file-transfer-peer-to-peer.jpg" alt="Large File Transfer - Peer to Peer File Sharing" style="width:100%; max-width:600px; border-radius:16px; box-shadow:0 4px 16px rgba(0,0,0,0.1); margin: 20px auto; display:block;">
            <div class="advantages-container">
                <div class="advantage-item">
                    <div class="advantage-icon">⚡</div>
                    <div class="advantage-content">
                        <h3>Send Large Files Faster Than Email or Cloud Storage</h3>
                        <p>Stop waiting hours for files to upload! Our direct peer-to-peer connection means your large files transfer at maximum speed - often 3x faster than Google Drive, Dropbox, or WeTransfer.</p>

                        <p>Whether you're sending a 5GB video file or a 10GB project folder, the transfer happens directly between devices without slow server uploads.
                            Most users see their large files transfer in just minutes, not hours. It's the quickest way to share big files when email says "attachment too large."</p>
                    </div>
                </div>

                <div class="advantage-item">
                    <div class="advantage-icon">🛡️</div>
                    <div class="advantage-content">
                        <h3>More Secure Than WeTransfer or Email Attachments</h3>
                        <p>Your files deserve better security than basic email or cloud sharing. Every file transfer uses military-grade end-to-end encryption, ensuring your sensitive documents, photos, and videos stay completely private.</p>
                        <p>
                            Unlike cloud services that store your files on servers, we create a direct encrypted connection between devices. Perfect for confidential business documents, medical records, legal files, or any sensitive information that needs secure file sharing.
                        </p>
                    </div>

                </div>
                
                <div class="advantage-item">
                    <div class="advantage-icon">🎯</div>
                    <div class="advantage-content">
                        <h3>No File Size Limits Like Email or Messaging Apps</h3>
                        <p>Fed up with "file too large" errors? We support files up to 10GB - that's 400 times larger than most email limits. Send full-resolution videos, complete photo albums, large presentations, or entire project folders without compression.</p>
                        <p>
                         Our temporary sharing links work perfectly for one-time file transfers. Links expire automatically after use, so your files stay private and aren't floating around the internet forever.
                        </p>
                    </div>
                </div>
                <div class="how-to-section">
            <h2>📁 How to Send Large Files in 3 Simple Steps</h2>
            <p class="how-to-intro">
                Sending large files online doesn't have to be complicated. Our browser-based file transfer tool makes it as easy as sending an email.
                No software downloads, no account creation - just follow these three steps to send files up to 10GB with complete security.
            </p>

            <div class="steps-container">
                <div class="step-item">
                    <div class="step-number">🚀</div>
                    <div class="step-content">
                        <h3>Step 1: Choose Your File</h3>
                        <p>Begin your secure file transfer by selecting any file from your device. Simply click "Choose File to Send" or drag and drop your file directly into the upload field. Our platform supports all file types without restrictions.
                            You can upload any file type - videos, images, documents, archives and more. There are no file size limits up to 10GB, so you can send even the largest files without compression or quality loss.</p>
                        </p>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">🔗</div>
                    <div class="step-content">
                        <h3>Step 2: Generate and Share Secure Link</h3>
                        <p>Once your file is selected, LargeFileTransfer.org instantly generates a unique, temporary sharing link and a QR code image.</p>

                        <p>Share your temporary file transfer link through any communication channel - email, messaging apps, social media, or even text messages. 
                            You can also share the QR code image so that mobile users can scan and download files instantly on their smartphones or tablets.</p>

                        <p>Each generated link is secured and unique to your transfer session, so that only intended recipients can access and download the files.</p>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">⚡</div>
                    <div class="step-content">
                        <h3>Step 3: Instant Direct Download</h3>
                        <p>Once the receiver click the temporary file sharing links, they will see comprehensive file details including name, size, and a simple "Accept & Download" button.</p>

                        <p>When they click "Accept & Download" you need to give a location where you want to save the file.
                            After that the file transfer and download process starts immediately with no waiting time. The file is sent directly from your device to theirs using peer-to-peer technology.</p>
                        <p>Both sender and receiver can monitor real-time progress with a dynamic progress bar and status updates, ensuring transparency throughout the transfer process.</p>
                    </div>
                </div>
            </div>

            </div>

            <div class="use-cases-section">
                <h2>🎪 Used Cases For LargeFileTransfer</h2>
                <div class="use-cases-content">
                    <h3>Share Videos and Audio File</h3>
                    <p> 
                    Send audio, video, and image files of almost any type—quickly and easily. Whether it’s a music track, a video clip, or a collection of photos, you can share them all without worrying about format issues. Perfect for creators, teams, and everyone who needs to move media files fast and hassle-free.
                    </p>
                    <h3>Transfer Confidential Files</h3>
                    <p>
                        You can safely transfer confidential files securely with our tool. Whether you're a doctor sending private health records, a lawyer sharing case files, a builder sending blueprints, or a teacher protecting student grades, your important documents are safe with us. 
                        You can send sensitive text, audio, video, and images, as we use strong encryption and strong privacy features for every file that you send.
                    </p>
                    <h3>Send Healthcare Documents</h3> 
                    <p>Share medical imaging files, patient records, and other healthcare documents securely. Our end-to-end encryption ensures that sensitive health information remains confidential, making it ideal for healthcare professionals who need to transfer large files quickly and safely.</p>
                    </p>
                    <h3>Send Server Logs - Quick Troubleshooting</h3>
                    <p>
                        IT professionals and system administrators can use our tool to send large server logs, system backups, and configuration files securely. 
                        The peer-to-peer transfer can send the logs to vendor or to colleague without any FTP or cloud storage services.
                        This is useful when logs are needed for troubleshooting or audits quickly.
                    </p>
                </div>
            </div>
        </div>

        <!-- How to Transfer Large Files Section -->
        
            <div class="how-to-advantages">
                <h3>Why Choose Our File Transfer Service Over Alternatives</h3>
                <div class="advantages-content">
                    <p><strong>Better Than Email for Large Files:</strong> While email limits you to 25MB attachments, we handle files up to 10GB without compression. No more "attachment too large" errors or splitting files into multiple parts.</p>

                    <p><strong>Faster Than Cloud Storage:</strong> Skip the slow upload-then-download process of Google Drive or Dropbox. Our direct peer-to-peer connection transfers files 3x faster than traditional cloud services.</p>

                    <p><strong>More Private Than WeTransfer:</strong> Your files never touch our servers. Unlike services that store your data temporarily, we create a direct encrypted tunnel between devices for maximum privacy.</p>

                    <p><strong>No Registration Like Dropbox Requires:</strong> Start sending large files immediately without accounts, passwords, or personal information. Professional file sharing made simple.</p>

                    <p><strong>Works on Any Device:</strong> Send large files from phone to computer, laptop to tablet, or any combination. Compatible with all modern browsers - no apps to download or software to install.</p>
                </div>
            </div>

            <div class="faq-section">
                <h2>❓ Frequently Asked Questions</h2>
                <div class="faq-container">
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>How to send files larger than 25MB that are too big for email?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>When email says "attachment too large," simply use our free file transfer service. We handle files up to 10GB - that's 400 times larger than typical email limits. Just drag and drop your file, get a sharing link, and send it to anyone instantly.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>Is my file transfer secure and private?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>Yes! All transfers use end-to-end encryption and direct peer-to-peer connections. Your files never pass through our servers - they go directly from your device to the recipient's device. The sharing links are temporary and expire after use.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>What file types are supported?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>All file types are supported! You can send videos, images, documents, archives, software, CAD files, audio files, and any other file format without restrictions.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>Do I need to create an account or install software?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>No registration or software installation required! LargeFileTransfer.org works directly in your web browser on any device - desktop, mobile, or tablet.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>Is this faster than WeTransfer, Google Drive, or Dropbox?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>Yes! Our peer-to-peer technology is significantly faster than cloud services. While WeTransfer and Google Drive require uploading to servers first, we transfer files directly between devices - often 3x faster. A 1GB file that takes 15 minutes on cloud services typically transfers in under 5 minutes with us.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>How long do sharing links stay active?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>Sharing links are temporary and expire after the file transfer is completed or if no one joins within 5 minutes. This ensures maximum security and privacy for your transfers.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>What browsers are supported?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>LargeFileTransfer.org works on all modern browsers including Chrome, Firefox, Safari, Edge, and mobile browsers. For the best experience with large files, we recommend Chrome or Edge which support direct file saving.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>Can I send files to multiple people at once?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>Currently, LargeFileTransfer.org supports one-to-one transfers for maximum security and speed. To send to multiple recipients, you can create separate transfer sessions for each person.</p>
                        </div>
                    </div>

                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFAQ(this)">
                            <h3>What happens if the transfer gets interrupted?</h3>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <p>If a transfer is interrupted due to connection issues, you'll need to start a new transfer session. We recommend ensuring both devices have stable internet connections before transferring large files.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="how-to-cta">
                <h3>🎯 Start Professional File Transfer</h3>
                <p>Experience the future of secure large file sharing with LargeFileTransfer.org. Complete transfers in under 30 seconds with enterprise-grade security and unlimited usage - completely free for all users.</p>
                <button class="btn how-to-btn" onclick="document.getElementById('drop-area').scrollIntoView({behavior: 'smooth'})">Begin Large File Transfer</button>
            </div>

            <!-- FAQ Section -->
            
        </div>

    </section>
    </main>

    <script src="/navbar.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js" integrity="sha512-11t8Q+vY9JlCrr+PveZKTYJq8n7O09Y5X/pk/aMd3vJugSvu4xOunGEUzaADqL3I8cZKE/pBwwCfXzDkRJh2sQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="/shared.js"></script>
    <script>
        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/sw.js')
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful');

                        // Request notification permission
                        if ('Notification' in window && Notification.permission === 'default') {
                            Notification.requestPermission();
                        }

                        // Register for periodic background sync after service worker is active
                        if ('periodicSync' in registration) {
                            navigator.serviceWorker.ready.then(function(reg) {
                                return reg.periodicSync.register('check-updates', {
                                    minInterval: 24 * 60 * 60 * 1000, // 24 hours
                                });
                            }).catch(function(error) {
                                // Periodic sync permission denied - this is normal
                                // Only available for highly engaged PWAs
                            });
                        }
                    })
                    .catch(function(error) {
                        console.log('ServiceWorker registration failed: ', error);
                    });

                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', function(event) {
                    if (event.data.type === 'RETRY_CONNECTION') {
                        // Retry connection logic
                        if (connectionState === 'failed' && !transferCancelled) {
                            console.log('Retrying connection due to background sync');
                            // You can add reconnection logic here
                        }
                    }
                });
            });
        }

        // Function to request background sync on connection failure
        function requestBackgroundSync() {
            if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
                navigator.serviceWorker.ready.then(function(registration) {
                    return registration.sync.register('retry-connection');
                }).catch(function(error) {
                    console.log('Background sync registration failed:', error);
                });
            }
        }
    </script>
    <script>
        // Test timeout formatting on page load
        if (DEBUG_MODE) {
            debugLog('Timeout configurations:', {
                waiting: `${formatTimeout(WAITING_FOR_RECEIVER_TIMEOUT)}`,
                connection: `${formatTimeout(CONNECTION_ESTABLISHMENT_TIMEOUT)}`
            });
        }

        let socket = null; // Initialize socket only when needed
        let pc; // PeerConnection
        let dataChannel;
        let fileToSend;
        let roomId = null; // Hold the room ID for the session
        let waitingTimeout = null; // Timeout for waiting for receiver to join
        let connectionTimeout = null; // Timeout for WebRTC connection establishment
        let connectionState = 'disconnected'; // disconnected, connecting, connected, failed
        let transferCancelled = false;


        // Sender-specific variables that cleanup function expects
        let fileWriter = null;
        let receiveBuffer = [];
        let receivedSize = 0;
        let transferCompleting = false;

        // --- DOM Elements ---
        const selectScreen = document.getElementById('select-screen');
        const shareScreen = document.getElementById('share-screen');
        const dropArea = document.getElementById('drop-area');
        const selectFileBtn = document.getElementById('select-file-btn');
        const fileInput = document.getElementById('file-input');
        const shareLink = document.getElementById('share-link');
        const qrCanvas = document.getElementById('qr-code');
        const sendAnotherBtn = document.getElementById('send-another-btn');



        // --- Signaling Logic --- (Moved to initializeSocket function)

        // --- UI Logic ---
        const path = window.location.pathname;
        const pathParts = path.split('/');

        // Only initialize file transfer functionality on relevant pages
        const isFileTransferPage = path.startsWith('/receive/') || path === '/';

        if (isFileTransferPage) {
            // Initialize file transfer functionality


        // Check if we are on a receiver URL, e.g., /receive/xyz123
        if (path.startsWith('/receive/') && pathParts.length === 3) {
            roomId = pathParts[2];

            // Validate room ID format
            if (!/^[a-z0-9]{8,15}$/i.test(roomId)) {
                showError('Invalid room ID format');
            }

            // --- Receiver Logic ---
            selectScreen.style.display = 'none';
            receiveScreen.style.display = 'block';
            showCompatibilityWarnings();

            if ('showSaveFilePicker' in window) {
                downloadBtn.textContent = 'Accept & Save';
            }

            // Initialize socket connection and join room
            initializeSocket();
            socket.emit('join-room', roomId);
            // Set up peer connection after joining room to prevent race conditions
            setTimeout(() => {
                setupPeerConnection(false);
            }, 100);

            const cancelBtn = document.getElementById('cancel-btn');
            cancelBtn.addEventListener('click', () => {
                cancelTransfer();
                // Return to home page
                window.location.href = '/';
            });

            downloadBtn.addEventListener('click', () => {
                acceptAndSaveFile();
                // Show cancel button once download starts
                setTimeout(() => {
                    cancelBtn.style.display = 'inline-block';
                }, 1000);
            });

            const trySendBtn = document.getElementById('try-send-btn'); // Declare here
            trySendBtn.addEventListener('click', () => {
                window.location.href = '/';
            });

        } else {
            // --- Sender Logic (home page handles sending) ---
            selectScreen.style.display = 'block'; // Make sure sender screen is visible

            showCompatibilityWarnings();

            dropArea.addEventListener('click', () => fileInput.click());
            dropArea.addEventListener('dragover', e => { e.preventDefault(); dropArea.classList.add('dragover'); });
            dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));
            dropArea.addEventListener('drop', e => {
                e.preventDefault();
                dropArea.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) {
                    handleFile(e.dataTransfer.files[0]);
                } else {
                    showError('No files were dropped', true);
                }
            });
            fileInput.addEventListener('change', e => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                } else {
                    showError('No file selected', true);
                }
            });

            // --- Share Button Logic ---
            const copyLinkBtn = document.getElementById('copy-link-btn');
            const shareBtn = document.getElementById('share-btn');

            copyLinkBtn.addEventListener('click', () => {
                shareLink.select();
                navigator.clipboard.writeText(shareLink.value).then(() => {
                    copyLinkBtn.textContent = 'Copied!';
                    setTimeout(() => { copyLinkBtn.textContent = 'Copy Link'; }, 2000);
                }).catch(err => {
                   
                    showError('Failed to copy link to clipboard', true);
                });
            });

            if (navigator.share) {
                shareBtn.style.display = 'inline-block';
                shareBtn.addEventListener('click', async () => {
                    try {
                        await navigator.share({
                            title: 'DirectDrop File Share',
                            text: 'A file is being shared with you. Click the link to receive it.',
                            url: shareLink.value
                        });
                    } catch (err) {
                        
                        showError('Failed to share link', true);
                    }
                });
            }
        }


        async function handleFile(file) {
            if (!validateFile(file)) {
                return;
            }

            fileToSend = file;
            roomId = generateSecureRoomId();
            const url = `${window.location.origin}/receive/${roomId}`;

            shareLink.value = url;
            new QRious({ element: qrCanvas, value: url, size: 150 });

            selectScreen.style.display = 'none';
            shareScreen.style.display = 'block';

            // Set initial status message with timeout info
            document.getElementById('share-status').textContent = `Waiting for recipient... (expires in ${formatTimeout(WAITING_FOR_RECEIVER_TIMEOUT)})`;
            document.getElementById('share-status').style.color = '';

            // Load TURN configuration before setting up peer connection
            await loadTurnConfig();

            // Initialize socket connection for sender
            initializeSocket();
            socket.emit('join-room', roomId);
            setupPeerConnection(true);

            // Start waiting timeout - if no receiver joins within 5 minutes
            startWaitingTimeout();
        }

        // --- Timeout Management Functions ---
        function startWaitingTimeout() {
            // Clear any existing waiting timeout
            if (waitingTimeout) {
                clearTimeout(waitingTimeout);
            }

           

            waitingTimeout = setTimeout(() => {
                
                document.getElementById('share-status').textContent = `Share link expired. No one joined within ${formatTimeout(WAITING_FOR_RECEIVER_TIMEOUT)}.`;
                document.getElementById('share-status').style.color = '#dc3545';
                // Show send another button
                sendAnotherBtn.style.display = 'block';
            }, WAITING_FOR_RECEIVER_TIMEOUT);
        }

        function clearWaitingTimeout() {
            if (waitingTimeout) {
                clearTimeout(waitingTimeout);
                waitingTimeout = null;
            }
        }

        function startConnectionTimeout() {
            // Clear any existing connection timeout
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
            }

            connectionTimeout = setTimeout(() => {
                if (connectionState !== 'connected') {
                    document.getElementById('share-status').textContent = `Connection failed. Unable to establish secure connection within ${formatTimeout(CONNECTION_ESTABLISHMENT_TIMEOUT)}.`;
                    document.getElementById('share-status').style.color = '#dc3545';
                    sendAnotherBtn.style.display = 'block';
                    cleanup();
                }
            }, CONNECTION_ESTABLISHMENT_TIMEOUT);
        }

        // --- Cleanup Functions ---
        function cleanup() {
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }

            if (waitingTimeout) {
                clearTimeout(waitingTimeout);
                waitingTimeout = null;
            }

            if (pc) {
                pc.close();
                pc = null;
            }

            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }

            if (fileWriter) {
                fileWriter.close().catch(() => {}); // Ignore errors on cleanup
                fileWriter = null;
            }

            // Clear receive buffer to prevent memory leaks
            receiveBuffer = [];
            receivedSize = 0;
            transferCancelled = false;
            transferCompleting = false;

            // Clear ICE candidate queue
            clearIceCandidateQueue();
        }

        // Initialize Socket.io connection only when needed
        function initializeSocket() {
            if (socket) return socket; // Already initialized

            socket = io(SIGNALING_SERVER_URL, {
                // Only connect when explicitly needed
                autoConnect: false,
                // Temporarily use polling-only to avoid WebSocket issues
                transports: ['polling'],
                // Disable upgrade for now
                upgrade: false,
                // Connection settings for production
                timeout: 10000,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 2000,
                // Production-specific settings
                forceNew: false,
                // Ping settings to match server
                pingTimeout: 60000,
                pingInterval: 25000
            });

            // Set up event handlers
            socket.on('connect', () => {
                debugLog('Connected to signaling server');
            });

            socket.on('disconnect', () => {
               
                showError('Lost connection to signaling server', true);
            });

            socket.on('connect_error', (error) => {
                
                showError('Could not connect to signaling server');
            });

            socket.on('user-joined', createOffer);
            socket.on('offer', (data) => handleOffer(data, pc, socket, roomId));
            socket.on('answer', (data) => handleAnswer(data, pc));
            socket.on('ice-candidate', (data) => handleIceCandidate(data, pc));
            socket.on('file-meta', handleFileMeta);
            socket.on('transfer-confirmed', handleTransferConfirmed);
            socket.on('user-left', handleUserLeft);

            // Connect now
            socket.connect();

            return socket;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);

        // Function to log which ICE servers are being used
        async function logIceServerUsage() {
            if (!pc) return;

            try {
                const stats = await pc.getStats();
                let stunUsed = false;
                let turnUsed = false;
                let relayUsed = false;
                let hostUsed = false;
                let usedCandidates = [];

                stats.forEach(report => {
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        const localId = report.localCandidateId;
                        const remoteId = report.remoteCandidateId;

                        // Find the local candidate details
                        stats.forEach(localReport => {
                            if (localReport.id === localId && localReport.type === 'local-candidate') {
                                const candidateInfo = {
                                    type: localReport.candidateType,
                                    protocol: localReport.protocol,
                                    address: localReport.address,
                                    port: localReport.port,
                                    relayProtocol: localReport.relayProtocol
                                };

                                usedCandidates.push(candidateInfo);

                                switch (localReport.candidateType) {
                                    case 'host':
                                        hostUsed = true;
                                        break;
                                    case 'srflx': // Server reflexive (STUN)
                                        stunUsed = true;
                                        break;
                                    case 'relay': // TURN relay
                                        relayUsed = true;
                                        turnUsed = true;
                                        break;
                                    case 'prflx': // Peer reflexive
                                        // This typically uses STUN
                                        stunUsed = true;
                                        break;
                                }
                            }
                        });
                    }
                });

                // Log the results
                if (usedCandidates.length > 0) {
                    let connectionType = '';
                    let serverType = '';

                    if (hostUsed && !stunUsed && !turnUsed) {
                        connectionType = 'Direct peer-to-peer';
                        serverType = 'None (local network)';
                    } else if (stunUsed && !turnUsed) {
                        connectionType = 'NAT traversal via STUN';
                        serverType = 'STUN servers';
                    } else if (turnUsed) {
                        connectionType = 'Relayed connection via TURN';
                        serverType = 'TURN relay servers';
                    }

                    console.log('🔗 WebRTC Connection Established:');
                    console.log(`   Connection Type: ${connectionType}`);
                    console.log(`   ICE Servers Used: ${serverType}`);
                    console.log('   Candidate Details:', usedCandidates);

                    // Also show in UI for non-debug mode
                    const statusElement = document.getElementById('share-status') || document.getElementById('receive-status');
                    if (statusElement && connectionType) {
                        const currentText = statusElement.textContent;
                        statusElement.textContent = `${currentText} (${connectionType})`;
                    }
                } else {
                    debugLog('No successful candidate pairs found in ICE stats');
                }
            } catch (error) {
                debugLog('Error getting ICE server usage stats:', error);
            }
        }

        // --- WebRTC Core Functions ---
        function setupPeerConnection(isInitiator) {
            cleanup(); // Clean up any existing connection
            clearIceCandidateQueue(); // Clear any queued ICE candidates

            pc = new RTCPeerConnection(rtcConfig);

            // Don't start connection timeout immediately for sender
            // It will be started when someone joins the room

            pc.oniceconnectionstatechange = () => {
              

                switch (pc.iceConnectionState) {
                    case 'connected':
                    case 'completed':
                        connectionState = 'connected';
                        // Clear all timeouts when successfully connected
                        clearWaitingTimeout();
                        if (connectionTimeout) {
                            clearTimeout(connectionTimeout);
                            connectionTimeout = null;
                        }
                        // Log which ICE servers were actually used
                        logIceServerUsage();
                        break;
                    case 'disconnected':
                        // If transfer was already completed, don't show reconnection error
                        if (connectionState === 'completed') {
                            document.getElementById('share-status').textContent = 'Transfer completed! Receiver has closed the connection.';
                            document.getElementById('share-status').style.color = '#28a745';
                        } else {
                            showError('Connection lost. Attempting to reconnect...', true);
                        }
                        break;
                    case 'failed':
                        showError('Connection failed. Please try again.');
                        cleanup();
                        break;
                    case 'closed':
                                    break;
                }
            };

            pc.onicecandidate = event => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { roomId, candidate: event.candidate });
                }
            };

            if (isInitiator) {
                dataChannel = pc.createDataChannel('fileTransfer', {
                    ordered: true
                });

                // Ensure consistent binary data handling across browsers
                dataChannel.binaryType = 'arraybuffer';

                dataChannel.onopen = () => {
                   
                    document.getElementById('share-status').textContent = 'Recipient connected. Waiting for them to accept the file.';
                    // Send metadata immediately so the receiver can display file info
                    socket.emit('file-meta', { roomId, metadata: { name: fileToSend.name, size: fileToSend.size } });
                };

                dataChannel.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        if (message.type === 'start') {
                          
                            document.getElementById('share-status').textContent = 'Sending file...';
                            sendFile();
                        } else if (message.type === 'cancel') {
                            showError('Transfer cancelled by recipient');
                            cleanup();
                        } else if (message.type === 'completed') {
                            connectionState = 'completed';
                            showSuccess('File transferred successfully!');

                            // Update UI to show completion without redirecting
                            document.getElementById('share-status').textContent = 'Transfer completed successfully!';
                            document.getElementById('share-status').style.color = '#28a745';

                            // Show "Send Another File" button
                            const sendAnotherBtn = document.getElementById('send-another-btn');
                            const cancelBtn = document.getElementById('cancel-btn');
                            if (sendAnotherBtn) sendAnotherBtn.style.display = 'block';
                            if (cancelBtn) cancelBtn.style.display = 'none';
                        }
                    } catch (e) {
                        debugLog("Received non-JSON message on data channel:", e);
                    }
                };

                dataChannel.onerror = (error) => {
                
                    showError('Data transfer error occurred');
                };

                dataChannel.onclose = () => {
                   
                    // Only show error if transfer was not completed successfully
                    if (!transferCancelled && connectionState !== 'completed') {
                        showError('Connection closed unexpectedly');
                    }
                };
            } else {
                pc.ondatachannel = event => {
                    dataChannel = event.channel;

                    // Ensure consistent binary data handling across browsers
                    dataChannel.binaryType = 'arraybuffer';

                    dataChannel.onmessage = handleDataChannelMessage;
                    dataChannel.onopen = () => {
                        debugLog('Data channel open with sender');
                    };
                    dataChannel.onclose = () => {
                     
                        // Only show error if transfer was not completed successfully
                        if (!transferCancelled && connectionState !== 'completed') {
                            showError('Connection closed by sender');
                        }
                    };
                    dataChannel.onerror = (error) => {
                       
                        showError('Data transfer error occurred');
                    };
                };
            }
        }

        async function createOffer(fromId) {
            if (!pc) return;

            // Someone joined! Clear waiting timeout and start connection timeout
            clearWaitingTimeout();
            document.getElementById('share-status').textContent = 'Receiver connected. Establishing secure connection...';
            document.getElementById('share-status').style.color = '';
            startConnectionTimeout();

            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('offer', { roomId, sdp: pc.localDescription });
                
            } catch (error) {
                
                showError('Failed to establish connection');
            }
        }


        // --- File Transfer Logic ---
        function sendFile() {
            resetProgressTracking(); // Reset progress tracking for new transfer
            let offset = 0;
            let chunkCount = 0;
            let totalChunks = Math.ceil(fileToSend.size / CHUNK_SIZE);
            let allDataSent = false;

          

            const readSliceAndSend = () => {
                if (offset >= fileToSend.size || transferCancelled) {
                
                    return;
                }

                const reader = new FileReader(); // Create a new reader for each slice
                reader.onload = (event) => {
                    if (dataChannel.readyState === 'open' && !transferCancelled) {
                        try {
                            const originalArrayBuffer = event.target.result;
                            const expectedSize = Math.min(CHUNK_SIZE, fileToSend.size - offset);

                            // Trim ArrayBuffer if it's larger than expected
                            let finalArrayBuffer;
                            if (originalArrayBuffer.byteLength > expectedSize) {
                                finalArrayBuffer = originalArrayBuffer.slice(0, expectedSize);
                            } else {
                                finalArrayBuffer = originalArrayBuffer;
                            }

                            const chunkSize = finalArrayBuffer.byteLength;
                            chunkCount++;

                            dataChannel.send(finalArrayBuffer);
                            const newOffset = offset + chunkSize;

                            // Update offset BEFORE checking completion to prevent infinite loop
                            offset = newOffset;
                            updateProgressBar('share-progress', offset, fileToSend.size);

                           

                            // Check if we've sent all the data
                            if (offset >= fileToSend.size) {
                                allDataSent = true;
                                
                                document.getElementById('share-status').textContent = 'File sent, waiting for receiver confirmation...';
                                // Don't close connection - wait for receiver confirmation
                                return; // Exit the function but keep connection open
                            }

                            // Continue sending if more data remains
                            if (!transferCancelled) {
                                // Fast approach - send immediately if buffer not full
                                if (dataChannel.bufferedAmount < CHUNK_SIZE * 2) {  // Only 256KB threshold
                                    readSliceAndSend();
                                }
                                // If buffer full, onbufferedamountlow will handle continuation
                            }
                        } catch (error) {
                            
                            showError('Error sending file chunk');
                        }
                    } else {
                        debugLog('Data channel not ready or transfer cancelled, skipping chunk');
                    }
                };

                reader.onerror = (error) => {
                    showError('Error reading file chunk');
                };

                reader.onloadend = (event) => {
                    if (event.target.error) {
                    } else {
                    }
                };

                const remainingBytes = fileToSend.size - offset;
                const sliceSize = Math.min(CHUNK_SIZE, remainingBytes);
                const slice = fileToSend.slice(offset, offset + sliceSize);

                reader.readAsArrayBuffer(slice);
            };

            dataChannel.onbufferedamountlow = () => {
                if (offset < fileToSend.size && !transferCancelled && !allDataSent) {
                    readSliceAndSend();
                }
            };

            readSliceAndSend();
        }

        function resetSenderState() {
            // Cleanup connection
            cleanup();

            // Hide share screen, show select screen
            shareScreen.style.display = 'none';
            selectScreen.style.display = 'block';

            // Reset variables
            fileToSend = null;
            roomId = null;

            // Reset UI elements
            fileInput.value = '';
            shareLink.value = '';
            document.getElementById('share-status').textContent = `Waiting for recipient... (expires in ${formatTimeout(WAITING_FOR_RECEIVER_TIMEOUT)})`;
            document.getElementById('share-status').style.color = '';
            document.getElementById('share-progress').style.width = '0%';
            sendAnotherBtn.style.display = 'none';

            // Clear QR code
            const context = qrCanvas.getContext('2d');
            context.clearRect(0, 0, qrCanvas.width, qrCanvas.height);
        }

        sendAnotherBtn.addEventListener('click', resetSenderState);

        // Handle transfer confirmation from receiver
        function handleTransferConfirmed() {
            connectionState = 'completed';
            showSuccess('File sent successfully!');
            sendAnotherBtn.style.display = 'block';
        }

        function handleUserLeft(data) {
            // If transfer was completed, show appropriate message
            if (connectionState === 'completed') {
                document.getElementById('share-status').textContent = 'Transfer completed! Receiver has closed the connection.';
                document.getElementById('share-status').style.color = '#28a745';
                return;
            }

            // If transfer was in progress or not completed
            if (connectionState === 'connected' && !transferCancelled) {
                showError('Receiver disconnected during transfer', false);
                document.getElementById('share-status').textContent = 'Transfer interrupted - receiver disconnected.';
            } else if (connectionState === 'connecting') {
                document.getElementById('share-status').textContent = 'Receiver left before transfer could begin. Share the link again.';
                document.getElementById('share-status').style.color = '#6c757d';
                sendAnotherBtn.style.display = 'block';
            }

            // Cleanup connection
            cleanup();
        }

        // Initialize compatibility check on page load
        document.addEventListener('DOMContentLoaded', () => {
            if (window.location.pathname.startsWith('/receive/')) {
                showCompatibilityWarnings();
            }
        });

        // Cancel transfer function
        function cancelTransfer() {
            transferCancelled = true;
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'cancel' }));
            }
            cleanup();
            showError('Transfer cancelled');
        }

        async function acceptAndSaveFile() {
            downloadBtn.disabled = true;

            if (!dataChannel || dataChannel.readyState !== 'open') {
                showError('Connection not ready. Please wait and try again.');
                downloadBtn.disabled = false;
                return;
            }

            const startTransfer = () => {
                try {
                    resetProgressTracking(); // Reset progress tracking for new transfer
                    dataChannel.send(JSON.stringify({ type: 'start' }));
                    
                    document.getElementById('receive-status').textContent = 'Transfer starting...';
                } catch (error) {
                    
                    showError('Failed to start transfer');
                    downloadBtn.disabled = false;
                }
            };

            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: receivingFile.name,
                        types: receivingFile.name.includes('.') ? [{
                            description: 'Files',
                            accept: { '*/*': ['.' + receivingFile.name.split('.').pop()] }
                        }] : undefined
                    });
                    fileWriter = await handle.createWritable();
                    downloadBtn.textContent = 'Saving...';
                    document.getElementById('receive-status').textContent = 'Saving file directly to disk...';
                    startTransfer();
                } catch (err) {
                    
                    if (err.name !== 'AbortError') {
                        showError('Failed to save file');
                    } else {
                        document.getElementById('receive-status').textContent = 'Save cancelled.';
                    }
                    downloadBtn.disabled = false;
                }
            } else {
                // Fallback for browsers that do not support the API
                downloadBtn.textContent = 'Downloading...';
                document.getElementById('receive-status').textContent = 'Preparing download...';
                startTransfer();
            }
        }

        async function handleDataChannelMessage(event) {
            if (transferCancelled || transferCompleting) {
                
                return;
            }

            // Check if we've already completed the transfer
            if (connectionState === 'completed') {
                
                return;
            }

            try {
                if (fileWriter) {
                    // Check if we're about to complete the transfer
                    if (receivedSize + event.data.byteLength >= receivingFile.size) {
                        debugLog('Final chunk received, preparing for completion');
                    }

                    try {
                        await fileWriter.write(event.data); // Await the write operation
                        receivedSize += event.data.byteLength;
                        updateProgressBar('receive-progress', receivedSize, receivingFile.size);

                        // Check if all data has been received
                        if (receivedSize >= receivingFile.size && !transferCompleting) {
                          
                            transferCompleting = true; // Prevent multiple calls
                            finalizeReceivedFile();
                        }
                    } catch (writeError) {
                  
                        showError('Error writing data to file');
                        cancelTransfer();
                    }
                } else {
                    // Check memory usage to prevent browser crashes
                    if (receiveBuffer.length > 1000) { // Roughly 64MB in memory
                        showError('File too large for in-memory download. Please use a browser that supports direct file saving.');
                        cancelTransfer();
                        return;
                    }

                    receiveBuffer.push(event.data);
                    receivedSize += event.data.byteLength;
                    updateProgressBar('receive-progress', receivedSize, receivingFile.size);
                }
            } catch (error) {
               
                showError('Error saving file data');
                cancelTransfer();
            }
        }
        
        function handleFileMeta(metadata) {
            if (!validateFile({ size: metadata.size, type: metadata.type || '', name: metadata.name })) {
                cancelTransfer();
                return;
            }

            receivingFile = metadata;
            document.getElementById('file-name').textContent = metadata.name;

            // Format file size appropriately
            let sizeText;
            if (metadata.size < 1024) {
                sizeText = `${metadata.size} B`;
            } else if (metadata.size < 1024 * 1024) {
                sizeText = `${(metadata.size / 1024).toFixed(1)} KB`;
            } else if (metadata.size < 1024 * 1024 * 1024) {
                sizeText = `${(metadata.size / 1024 / 1024).toFixed(1)} MB`;
            } else {
                sizeText = `${(metadata.size / 1024 / 1024 / 1024).toFixed(1)} GB`;
            }

            document.getElementById('file-size').textContent = sizeText;
            document.getElementById('receive-status').textContent = 'Ready to download.';
            downloadBtn.disabled = false;
        }

        async function finalizeReceivedFile() {
            if (transferCancelled) {
                return;
            }

          

            try {
                if (fileWriter) {
                  
                    updateProgressBar('receive-progress', receivingFile.size, receivingFile.size);
                    document.getElementById('receive-status').textContent = 'Finalizing file...';

                    await fileWriter.close();
                  

                    connectionState = 'completed';
                    showSuccess('Transfer completed! You can now download the file.');
                    setTimeout(() => {
                        document.getElementById('receive-status').textContent = 'Transfer completed! You can now download the file.';
                        document.getElementById('receive-status').style.color = '#28a745'; // Ensure color is set
                    }, 50);

                    socket.emit('transfer-confirmed', { roomId });
                    
                    // # hide the download button and cancel button
                    downloadBtn.style.display = 'none';
                    const cancelBtn = document.getElementById('cancel-btn');
                    if (cancelBtn) cancelBtn.style.display = 'none';
                    const trySendBtn = document.getElementById('try-send-btn');
                    if (trySendBtn) trySendBtn.style.display = 'block'; // Show try send button
                } else if (receiveBuffer.length > 0) {
                    
                    updateProgressBar('receive-progress', receivingFile.size, receivingFile.size);
                    document.getElementById('receive-status').textContent = 'Preparing download...';

                    const receivedBlob = new Blob(receiveBuffer);
                    receiveBuffer = []; // Clear buffer
                    
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(receivedBlob);
                    downloadLink.download = receivingFile.name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);

                    setTimeout(() => URL.revokeObjectURL(downloadLink.href), 1000);

                    connectionState = 'completed';
                    showSuccess('File received successfully!');
                    setTimeout(() => {
                        document.getElementById('receive-status').textContent = 'File received successfully!';
                        document.getElementById('receive-status').style.color = '#28a745'; // Ensure color is set
                    }, 50);
                    downloadBtn.style.display = 'none';
                    const cancelBtn = document.getElementById('cancel-btn');
                    if (cancelBtn) cancelBtn.style.display = 'none';

                    socket.emit('transfer-confirmed', { roomId });
                    
                } else {
                   
                    connectionState = 'completed';
                    const message = 'Transfer completed, but no file was saved. Click "Accept & Download" to save the file.';
                    showSuccess(message);
                    document.getElementById('receive-status').textContent = message;
                    downloadBtn.style.display = 'none'; // Hide download button
                    const cancelBtn = document.getElementById('cancel-btn');
                    if (cancelBtn) cancelBtn.style.display = 'none'; // Hide cancel button
                    const trySendBtn = document.getElementById('try-send-btn');
                    if (trySendBtn) trySendBtn.style.display = 'block'; // Show try send button

                    socket.emit('transfer-confirmed', { roomId });
                  
                }
            } catch (error) {
                
                showError('Error completing file transfer');
                socket.emit('transfer-confirmed', { roomId });
            }
        }

        } // End of isFileTransferPage check


    </script>
    </div>
    <footer class="footer-main">
        <div class="footer-content">
            <div class="footer-links">
                <a href="/privacy">Privacy Policy</a>
                <a href="/terms">Terms of Service</a>
            </div>
            <div class="footer-social">
                <a href="https://twitter.com/intent/tweet?text=Check%20out%20LargeFileTransfer.org%20-%20Send%20large%20files%20up%20to%2010GB%20for%20free%20with%20end-to-end%20encryption!&url=https://largefiletransfer.org" target="_blank" rel="noopener" aria-label="Share on Twitter">
                    <i class="fab fa-twitter"></i>
                </a>
                <a href="https://www.facebook.com/sharer/sharer.php?u=https://largefiletransfer.org" target="_blank" rel="noopener" aria-label="Share on Facebook">
                    <i class="fab fa-facebook-f"></i>
                </a>
                <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://largefiletransfer.org" target="_blank" rel="noopener" aria-label="Share on LinkedIn">
                    <i class="fab fa-linkedin-in"></i>
                </a>
                <a href="https://reddit.com/submit?url=https://largefiletransfer.org&title=Free%20Large%20File%20Transfer%20-%20Send%20Files%20up%20to%2010GB" target="_blank" rel="noopener" aria-label="Share on Reddit">
                    <i class="fab fa-reddit-alien"></i>
                </a>
                <a href="mailto:?subject=Check%20out%20LargeFileTransfer.org&body=I%20found%20this%20great%20tool%20for%20sending%20large%20files%20securely:%20https://largefiletransfer.org" aria-label="Share via Email">
                    <i class="fas fa-envelope"></i>
                </a>
            </div>
            <p class="footer-copyright">&copy; 2025 LargeFileTransfer.org. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>