<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <meta name="theme-color" content="#667eea">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="DirectDrop">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <meta name="msapplication-TileImage" content="/icon-192.png">
    <meta name="msapplication-TileColor" content="#667eea">
    <title>Receive File | Large File Transfer</title>
    <meta name="description" content="Secure file receiving page - Download your shared file with end-to-end encryption.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <div id="navbar-container"></div>

    <main class="main-content-wrapper" role="main">
        <section class="container" aria-label="File receiving interface">
            <!-- Receive Screen -->
            <div id="receive-screen" role="region" aria-label="File receiving interface">
                <h1>Incoming File</h1>
                <p>You are about to receive a file.</p>
                <div class="file-info">
                    <p><strong>Filename:</strong> <span id="file-name">Loading...</span></p>
                    <p><strong>Size:</strong> <span id="file-size">Loading...</span></p>
                </div>
                <button class="btn" id="download-btn" disabled>Accept & Download</button>
                <button class="btn btn-cancel" id="cancel-btn" style="display: none;">Cancel</button>
                <p id="receive-status" style="margin-top: 20px;">Connecting...</p>
                <div class="progress-bar" id="receive-progress-bar">
                    <div class="progress-bar-inner" id="receive-progress"></div>
                </div>
                <button class="btn" id="try-send-btn" style="display: none; margin-top: 20px;">Try Sending File</button>

                <div class="footer">
                    <div class="security-badge">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"></path></svg>
                        Secure File Transfer End-to-End Encrypted
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="/navbar.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js" integrity="sha512-11t8Q+vY9JlCrr+PveZKTYJq8n7O09Y5X/pk/aMd3vJugSvu4xOunGEUzaADqL3I8cZKE/pBwwCfXzDkRJh2sQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="/shared.js"></script>
    <script>
        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/sw.js')
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(function(error) {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>
    <script>
        // Receiver-specific timeout configuration
        const CONNECTION_TIMEOUT = 5 * 60 * 1000; // 5 minutes

        const socket = io(SIGNALING_SERVER_URL);
        let pc; // PeerConnection
        let dataChannel;
        let receivingFile;
        let receivedSize = 0;
        let receiveBuffer = [];
        let fileWriter = null; // For File System Access API
        let roomId = null; // Hold the room ID for the session
        let connectionTimeout = null;
        let connectionState = 'disconnected'; // disconnected, connecting, connected, failed
        let transferCancelled = false;
        let transferCompleting = false;

        // --- DOM Elements ---
        const downloadBtn = document.getElementById('download-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const trySendBtn = document.getElementById('try-send-btn');


        // --- Signaling Logic ---
        socket.on('connect', () => {
            debugLog('Connected to signaling server');
        });

        socket.on('disconnect', () => {
            debugLog('Disconnected from signaling server');
            showError('Lost connection to signaling server', true);
        });

        socket.on('connect_error', (error) => {
            debugLog('Signaling server connection error:', error);
            showError('Could not connect to signaling server');
        });

        socket.on('offer', (data) => handleOffer(data, pc, socket, roomId));
        socket.on('answer', (data) => handleAnswer(data, pc));
        socket.on('ice-candidate', (data) => handleIceCandidate(data, pc));
        socket.on('file-meta', handleFileMeta);
        socket.on('transfer-confirmed', handleTransferConfirmed);
        socket.on('user-left', handleSenderLeft);

        // --- Extract room ID from URL ---
        const path = window.location.pathname;
        const pathParts = path.split('/');

        if (path.startsWith('/receive/') && pathParts.length === 3) {
            roomId = pathParts[2];

            // Validate room ID format
            if (!/^[a-z0-9]{8,15}$/i.test(roomId)) {
                showError('Invalid room ID format');
            } else {
                // Initialize connection
                initializeReceiver();
            }
        } else {
            showError('Invalid receive URL');
        }

        async function initializeReceiver() {
            showCompatibilityWarnings();

            if ('showSaveFilePicker' in window) {
                downloadBtn.textContent = 'Accept & Save';
            }

            // Load TURN configuration before setting up peer connection
            await loadTurnConfig();

            // Initialize peer connection and join room
            
            socket.emit('join-room', roomId);
            setTimeout(() => {
                setupPeerConnection(false);
            }, 100);

            // Event listeners
            cancelBtn.addEventListener('click', () => {
                cancelTransfer();
                window.location.href = '/';
            });

            downloadBtn.addEventListener('click', () => {
                acceptAndSaveFile();
                setTimeout(() => {
                    cancelBtn.style.display = 'inline-block';
                }, 1000);
            });

            trySendBtn.addEventListener('click', () => {
                window.location.href = '/';
            });
        }


        // --- Cleanup Functions ---
        function cleanup() {
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }

            if (pc) {
                pc.close();
                pc = null;
            }

            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }

            if (fileWriter) {
                fileWriter.close().catch(() => {}); // Ignore errors on cleanup
                fileWriter = null;
            }

            receiveBuffer = [];
            receivedSize = 0;
            transferCancelled = false;
            transferCompleting = false;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);

        // --- WebRTC Core Functions ---
        function setupPeerConnection(isInitiator) {
            cleanup(); // Clean up any existing connection
            clearIceCandidateQueue(); // Clear any queued ICE candidates

            pc = new RTCPeerConnection(rtcConfig);

            // Set connection timeout
            connectionTimeout = setTimeout(() => {
                if (connectionState !== 'connected') {
                    showError('Connection timeout. Please try again.');
                    cleanup();
                }
            }, CONNECTION_TIMEOUT);

            pc.oniceconnectionstatechange = () => {
        

                switch (pc.iceConnectionState) {
                    case 'connected':
                    case 'completed':
                        if (connectionTimeout) {
                            clearTimeout(connectionTimeout);
                            connectionTimeout = null;
                        }
                        break;
                    case 'disconnected':
                        // If transfer was already completed, don't show reconnection error
                        if (connectionState === 'completed') {
                            document.getElementById('receive-status').textContent = 'Transfer completed successfully. You can close this page.';
                            document.getElementById('receive-status').style.color = '#28a745';
                        } else {
                            showError('Connection lost. Attempting to reconnect...', true);
                        }
                        break;
                    case 'failed':
                        showError('Connection failed. Please try again.');
                        cleanup();
                        break;
                    case 'closed':
                        break;
                }
            };

            pc.onicecandidate = event => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { roomId, candidate: event.candidate });
                }
            };

            pc.ondatachannel = event => {
                dataChannel = event.channel;

                // Ensure consistent binary data handling across browsers
                dataChannel.binaryType = 'arraybuffer';


                dataChannel.onmessage = handleDataChannelMessage;
                dataChannel.onopen = () => {
                };
                dataChannel.onclose = () => {
                    if (!transferCancelled && connectionState !== 'completed') {
                        showError('Connection closed by sender');
                    }
                };
                dataChannel.onerror = (error) => {
                    showError('Data channel error occurred');
                };
            };
        }

        async function handleOffer(data) {
            if (roomId && pc && pc.signalingState === 'stable') {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socket.emit('answer', { roomId, sdp: pc.localDescription });
                    debugLog('Answer created and sent');
                } catch (error) {
                    debugLog('Error handling offer:', error);
                    showError('Failed to establish connection');
                }
            }
        }

        async function handleAnswer(data) {
            if (pc && pc.signalingState === 'have-local-offer') {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                   
                } catch (error) {
                    
                    showError('Failed to establish connection');
                }
            }
        }

        async function handleIceCandidate(data) {
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                
                } catch (error) {
                    debugLog('Error adding ICE candidate:', error);
                }
            }
        }


        function handleFileMeta(metadata) {
           

            if (!validateFile({ size: metadata.size, type: metadata.type || '', name: metadata.name })) {
                cancelTransfer();
                return;
            }

            receivingFile = metadata;
            document.getElementById('file-name').textContent = metadata.name;

            // Format file size appropriately
            let sizeText;
            if (metadata.size < 1024) {
                sizeText = `${metadata.size} B`;
            } else if (metadata.size < 1024 * 1024) {
                sizeText = `${(metadata.size / 1024).toFixed(1)} KB`;
            } else if (metadata.size < 1024 * 1024 * 1024) {
                sizeText = `${(metadata.size / 1024 / 1024).toFixed(1)} MB`;
            } else {
                sizeText = `${(metadata.size / 1024 / 1024 / 1024).toFixed(1)} GB`;
            }

            document.getElementById('file-size').textContent = sizeText;
            document.getElementById('receive-status').textContent = 'Ready to download.';
            downloadBtn.disabled = false;
        }

        function cancelTransfer() {
            transferCancelled = true;
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'cancel' }));
            }
            cleanup();
            showError('Transfer cancelled');
        }

        async function acceptAndSaveFile() {
            downloadBtn.disabled = true;


            if (!dataChannel || dataChannel.readyState !== 'open') {
                showError('Connection not ready. Please wait and try again.');
                downloadBtn.disabled = false;
                return;
            }

            const startTransfer = () => {
                try {
                    resetProgressTracking();

                    // Reset chunk counters
                    receivedChunkCount = 0;
                    expectedChunks = 0;

                    dataChannel.send(JSON.stringify({ type: 'start' }));
                    document.getElementById('receive-status').textContent = 'Transfer starting...';
                } catch (error) {
                    showError('Failed to start transfer');
                    downloadBtn.disabled = false;
                }
            };

            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: receivingFile.name,
                        types: receivingFile.name.includes('.') ? [{
                            description: 'Files',
                            accept: { '*/*': ['.' + receivingFile.name.split('.').pop()] }
                        }] : undefined
                    });
                    fileWriter = await handle.createWritable();
                    downloadBtn.textContent = 'Saving...';
                    document.getElementById('receive-status').textContent = 'Saving file directly to disk...';
                    startTransfer();
                } catch (err) {
                    debugLog('File save picker cancelled or failed:', err);
                    if (err.name !== 'AbortError') {
                        showError('Failed to save file');
                    } else {
                        document.getElementById('receive-status').textContent = 'Save cancelled.';
                    }
                    downloadBtn.disabled = false;
                }
            } else {
                downloadBtn.textContent = 'Downloading...';
                document.getElementById('receive-status').textContent = 'Preparing download...';
                startTransfer();
            }
        }

        let receivedChunkCount = 0;
        let expectedChunks = 0;

        async function handleDataChannelMessage(event) {

            if (transferCancelled || transferCompleting) {
                debugLog('Transfer cancelled or completing, ignoring data');
                return;
            }

            if (connectionState === 'completed') {
                debugLog('Transfer already completed, ignoring extra data');
                return;
            }

            if (typeof event.data === 'string') {
                // This is likely a control message (start signal response)
                return;
            }

            // Calculate expected chunks when we receive the first data chunk
            if (receivedChunkCount === 0 && receivingFile) {
                expectedChunks = Math.ceil(receivingFile.size / CHUNK_SIZE);
            }

            // Convert data to ArrayBuffer if needed
            let dataBuffer;
            if (event.data instanceof ArrayBuffer) {
                dataBuffer = event.data;
            } else if (event.data instanceof Blob) {
                dataBuffer = await event.data.arrayBuffer();
            } else if (typeof event.data === 'object' && event.data.constructor.name === 'ArrayBuffer') {
                dataBuffer = event.data;
            } else {
                return;
            }

            // Validate data integrity
            if (!dataBuffer || dataBuffer.byteLength === 0) {
                return;
            }

            receivedChunkCount++;

            try {
                if (fileWriter) {
                    if (receivedSize + dataBuffer.byteLength >= receivingFile.size) {
                        debugLog('Final chunk received, preparing for completion. Total received will be:', receivedSize + dataBuffer.byteLength);
                    }

                    try {
                        // Verify we're not writing more data than expected
                        if (receivedSize + dataBuffer.byteLength > receivingFile.size) {
                            // Trim the buffer to exact remaining size
                            const remainingBytes = receivingFile.size - receivedSize;
                            if (remainingBytes > 0) {
                                const trimmedBuffer = dataBuffer.slice(0, remainingBytes);
                                await fileWriter.write(trimmedBuffer);
                                receivedSize += trimmedBuffer.byteLength;
                            }
                        } else {
                            await fileWriter.write(dataBuffer);
                            receivedSize += dataBuffer.byteLength;
                        }

                        updateProgressBar('receive-progress', receivedSize, receivingFile.size);

                        if (receivedSize >= receivingFile.size && !transferCompleting) {
                            debugLog('All data received, initiating finalization. Final size:', receivedSize, 'Chunks received:', receivedChunkCount, 'Expected:', expectedChunks);
                            transferCompleting = true;
                            finalizeReceivedFile();
                        }
                    } catch (writeError) {
                        debugLog('Write error to file stream:', writeError);
                        showError('Error writing data to file');
                        cancelTransfer();
                    }
                } else {
                    if (receiveBuffer.length > 32768) {  // 4GB limit (32768 * 128KB = 4GB)
                        showError('File too large for in-memory download. Maximum size is 4GB for browsers without direct file saving support.');
                        cancelTransfer();
                        return;
                    }

                    // Verify we're not storing more data than expected
                    if (receivedSize + dataBuffer.byteLength > receivingFile.size) {
                        const remainingBytes = receivingFile.size - receivedSize;
                        if (remainingBytes > 0) {
                            const trimmedBuffer = dataBuffer.slice(0, remainingBytes);
                            receiveBuffer.push(trimmedBuffer);
                            receivedSize += trimmedBuffer.byteLength;
                        }
                    } else {
                        receiveBuffer.push(dataBuffer);
                        receivedSize += dataBuffer.byteLength;
                    }

                    updateProgressBar('receive-progress', receivedSize, receivingFile.size);

                    if (receivedSize >= receivingFile.size && !transferCompleting) {
                        debugLog('All data received in memory, initiating finalization. Final size:', receivedSize, 'Chunks received:', receivedChunkCount, 'Expected:', expectedChunks);
                        transferCompleting = true;
                        finalizeReceivedFile();
                    }
                }
            } catch (error) {
                debugLog('Error handling data:', error);
                showError('Error saving file data');
                cancelTransfer();
            }
        }

        async function finalizeReceivedFile() {
            if (transferCancelled) {
                return;
            }

            debugLog('Finalizing received file');

            try {
                if (fileWriter) {
                    debugLog('Closing file writer to flush data to disk');
                    updateProgressBar('receive-progress', receivingFile.size, receivingFile.size);
                    document.getElementById('receive-status').textContent = 'Finalizing file...';

                    await fileWriter.close();
                    debugLog('File System API write completed');

                    connectionState = 'completed';
                    showSuccess('Transfer completed! File saved successfully.');
                    setTimeout(() => {
                        document.getElementById('receive-status').textContent = 'Transfer completed! File saved successfully.';
                        document.getElementById('receive-status').style.color = '#28a745';
                    }, 50);

                    // Send confirmation via both Socket.io and data channel
                    socket.emit('transfer-confirmed', { roomId });

                    // Send direct confirmation to sender via data channel
                    if (dataChannel && dataChannel.readyState === 'open') {
                        try {
                            dataChannel.send(JSON.stringify({ type: 'completed' }));
                            debugLog('Direct completion confirmation sent to sender via data channel');
                        } catch (error) {
                            debugLog('Error sending completion confirmation via data channel:', error);
                        }
                    }

                    debugLog('Confirmation sent to sender via Socket.io');

                    downloadBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    trySendBtn.style.display = 'block';
                } else if (receiveBuffer.length > 0) {
                    debugLog('Using blob fallback for download');
                    updateProgressBar('receive-progress', receivingFile.size, receivingFile.size);
                    document.getElementById('receive-status').textContent = 'Preparing download...';

                    const receivedBlob = new Blob(receiveBuffer);
                    receiveBuffer = [];

                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(receivedBlob);
                    downloadLink.download = receivingFile.name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);

                    setTimeout(() => URL.revokeObjectURL(downloadLink.href), 1000);

                    connectionState = 'completed';
                    showSuccess('File received successfully!');
                    setTimeout(() => {
                        document.getElementById('receive-status').textContent = 'File received successfully!';
                        document.getElementById('receive-status').style.color = '#28a745';
                    }, 50);
                    downloadBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    trySendBtn.style.display = 'block';

                    // Send confirmation via both Socket.io and data channel
                    socket.emit('transfer-confirmed', { roomId });

                    // Send direct confirmation to sender via data channel
                    if (dataChannel && dataChannel.readyState === 'open') {
                        try {
                            dataChannel.send(JSON.stringify({ type: 'completed' }));
                            debugLog('Direct completion confirmation sent to sender via data channel');
                        } catch (error) {
                            debugLog('Error sending completion confirmation via data channel:', error);
                        }
                    }

                    debugLog('Blob download completed, confirmation sent to sender');
                }
            } catch (error) {
                debugLog('Error in finalizeReceivedFile:', error);
                showError('Error completing file transfer');
                socket.emit('transfer-confirmed', { roomId });
            }
        }

        function handleTransferConfirmed() {
            // This function is not used in receiver, but kept for compatibility
        }

        function handleSenderLeft(data) {
            // If transfer was completed, just show a neutral message
            if (connectionState === 'completed') {
                document.getElementById('receive-status').textContent = 'Transfer completed successfully. You can close this page.';
                document.getElementById('receive-status').style.color = '#28a745';
                return;
            }

            // If transfer was in progress or not completed
            if (connectionState === 'connected' && !transferCancelled) {
                document.getElementById('receive-status').textContent = 'Transfer interrupted - sender disconnected.';
                document.getElementById('receive-status').style.color = '#dc3545';
            } else if (connectionState === 'connecting') {
                document.getElementById('receive-status').textContent = 'Sender left before transfer could begin. This link is no longer valid.';
                document.getElementById('receive-status').style.color = '#6c757d';
            }

            // Cleanup connection
            cleanup();
        }


    </script>

    <footer class="footer-main">
        <div class="footer-content">
            <div class="footer-links">
                <a href="/privacy">Privacy Policy</a>
                <a href="/terms">Terms of Service</a>
            </div>
            <div class="footer-social">
                <a href="https://twitter.com/intent/tweet?text=Check%20out%20LargeFileTransfer.org%20-%20Send%20large%20files%20up%20to%2010GB%20for%20free%20with%20end-to-end%20encryption!&url=https://largefiletransfer.org" target="_blank" rel="noopener" aria-label="Share on Twitter">
                    <i class="fab fa-twitter"></i>
                </a>
                <a href="https://www.facebook.com/sharer/sharer.php?u=https://largefiletransfer.org" target="_blank" rel="noopener" aria-label="Share on Facebook">
                    <i class="fab fa-facebook-f"></i>
                </a>
                <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://largefiletransfer.org" target="_blank" rel="noopener" aria-label="Share on LinkedIn">
                    <i class="fab fa-linkedin-in"></i>
                </a>
                <a href="https://reddit.com/submit?url=https://largefiletransfer.org&title=Free%20Large%20File%20Transfer%20-%20Send%20Files%20up%20to%2010GB" target="_blank" rel="noopener" aria-label="Share on Reddit">
                    <i class="fab fa-reddit-alien"></i>
                </a>
                <a href="mailto:?subject=Check%20out%20LargeFileTransfer.org&body=I%20found%20this%20great%20tool%20for%20sending%20large%20files%20securely:%20https://largefiletransfer.org" aria-label="Share via Email">
                    <i class="fas fa-envelope"></i>
                </a>
            </div>
            <p class="footer-copyright">&copy; 2025 LargeFileTransfer.org. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>